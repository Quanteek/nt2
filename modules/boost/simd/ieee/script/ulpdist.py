[ ## this file was manually modified by jt
    {
     'functor' : {
         'description' : ['Returns ulp distance of the two values.','\par',
                          '\\\\arg If the common type is integer it is the same as \c dist',
                          '\\\\arg If the common type is floating point the ulpdist is is computed,',
                          'by the above described method',
                          '\par',
                          'It is often difficult to  answer to the following question:',
                          '\\\\arg are these two floating computations results similar enough?',
                          '\par',
                          'The ulpdist is a way to answer which is tuned for relative errors estimations',
                          'and peculiarly adapted to cope with the limited bits accuracy of floating point', 
                          'representations.',
                          'The method is the following:', '\par',
                          'Properly normalize the two numbers by the same factor in a way that ',
                          'the largest of the two numbers exponents will be brought to zero',
                          'Return the absolute difference of these normalized numbers',
                          'divided by the rounding error Eps',
                          '\par',
                          'The roundind error is the ulp (unit in the last place) value, i.e. the',
                          'floating number, the exponent of which is 0 and the mantissa is all zeros',
                          'but a 1 in the last digit (it is not hard coded that way however).',
                          'This means 2^-23 for floats and 2^-52 for double',
                          '\\\\arg For instance if two floating numbers (of same type) have an ulpdist of ',
                          'zero that means that their floating representation are identical.',
                          '\\\\arg Generally equality up to 0.5 ulp is the best that one can wish beyond',
                          'strict equality.',
                          '\\\\arg Typically if a double is compared to the float representation of',
                          'its floating conversion (they are exceptions as for fully representable',
                          'reals) the ulpdist will be around 2^26.5 (~10^8)',
                          '\par',
                          'The ulpdist is also roughly equivalent to the number of representable',
                          'floating points values between two given floating points values.',
                          '\par',
                          '\\\\arg  \c ulpdist(1.0,1+Eps\<double\\>())==0.5',
                          '\\\\arg  \c ulpdist(1.0,1+Eps\<double\>()/2)==0.0',
                          '\\\\arg  \c ulpdist(1.0,1-Eps\<double\>()/2)==0.25',
                          '\\\\arg  \c ulpdist(1.0,1-Eps\<double\>())==0.5 ',
                          '\\\\arg  \c ulpdist(double(Pi\<float\>()),Pi\<double\>())==9.84293e+07',
                          ],   
          'module' : 'boost',
         'arity' : '2',
         'call_types' : [],
         'ret_arity' : '0',
         'rturn' : {
             'default' : 'typename boost::common_type<T>::type',
            },
         'simd_types' : ['real_'],
         'type_defs' : [],
         'types' : ['real_', 'unsigned_int_', 'signed_int_'],
        },
     'info' : 'manually modified',
     'unit' : {
         'global_header' : {
             'first_stamp' : 'modified by jt the 04/12/2010',
             'included' : [],
             'no_ulp' : 'True',
             'notes' : [],
             'stamp' : 'modified by jt the 12/12/2010',
            },
         'ranges' : {
             'real_' : [['T(-10)', 'T(10)'], ['T(-10)', 'T(10)']],
             'signed_int_' : [['-100', '100'], ['-100', '100']],
             'unsigned_int_' : [['0', '100'], ['0', '100']],
            },
         'specific_values' : {
             'default' : {
                },
             'real_' : {
                 'boost::simd::Inf<T>()' : 'boost::simd::Zero<r_t>()',
                 'boost::simd::Minf<T>()' : 'boost::simd::Zero<r_t>()',
                 'boost::simd::Mone<T>()' : 'boost::simd::Zero<r_t>()',
                 'boost::simd::Nan<T>()' : 'boost::simd::Zero<r_t>()',
                 'boost::simd::One<T>()' : 'boost::simd::Zero<r_t>()',
                 'boost::simd::Zero<T>()' : 'boost::simd::Zero<r_t>()',
                },
             'signed_int_' : {
                 'boost::simd::Mone<T>()' : 'boost::simd::Zero<r_t>()',
                 'boost::simd::One<T>()' : 'boost::simd::Zero<r_t>()',
                 'boost::simd::Zero<T>()' : 'boost::simd::Zero<r_t>()',
                },
             'unsigned_int_' : {
                 'boost::simd::One<T>()' : 'boost::simd::Zero<r_t>()',
                 'boost::simd::Zero<T>()' : 'boost::simd::Zero<r_t>()',
                },
            },
         'verif_test' : {
            },
        },
     'version' : '0.1',
    },
]
