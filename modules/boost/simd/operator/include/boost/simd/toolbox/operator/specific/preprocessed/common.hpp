////////////////////////////////////////////////////////////////////////////////
// Register all tag and extension agnostic call for common code sharing
////////////////////////////////////////////////////////////////////////////////
namespace boost { namespace simd { namespace ext
{
  } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > ) , tag::cpu_ > dispatching( elementwise_<Tag> , tag::cpu_ , generic_< unspecified_<A0> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > ) , tag::cpu_ > dispatching( elementwise_<Tag> , tag::cpu_ , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 , class A2 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > ) , tag::cpu_ > dispatching( elementwise_<Tag> , tag::cpu_ , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , generic_< unspecified_<A2> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 , class A2 , class A3 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > ) , tag::cpu_ > dispatching( elementwise_<Tag> , tag::cpu_ , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , generic_< unspecified_<A2> > const , generic_< unspecified_<A3> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 , class A2 , class A3 , class A4 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > ) , tag::cpu_ > dispatching( elementwise_<Tag> , tag::cpu_ , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , generic_< unspecified_<A2> > const , generic_< unspecified_<A3> > const , generic_< unspecified_<A4> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Tag , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > , generic_< unspecified_<A5> > ) , tag::cpu_ > dispatching( elementwise_<Tag> , tag::cpu_ , generic_< unspecified_<A0> > const , generic_< unspecified_<A1> > const , generic_< unspecified_<A2> > const , generic_< unspecified_<A3> > const , generic_< unspecified_<A4> > const , generic_< unspecified_<A5> > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< elementwise_<Tag> ( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > , generic_< unspecified_<A5> > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext {
} } }
////////////////////////////////////////////////////////////////////////////////
// Generate all the common map calls over Tag using boost::simd::map
////////////////////////////////////////////////////////////////////////////////
namespace boost { namespace simd { namespace ext { template<class A0,class Tag, class Dummy> struct implement< elementwise_<Tag>( generic_< unspecified_<A0> > ) , tag::cpu_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0> struct result<This(_A0)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 ) > { }; template<class _A0> typename result<implement(_A0 & a0)>::type operator()(_A0 & a0) const { return map( dispatch::functor<Tag>(), a0 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1,class Tag, class Dummy> struct implement< elementwise_<Tag>( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > ) , tag::cpu_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1> struct result<This(_A0 , _A1)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 ) > { }; template<class _A0 , class _A1> typename result<implement(_A0 & a0 , _A1 & a1)>::type operator()(_A0 & a0 , _A1 & a1) const { return map( dispatch::functor<Tag>(), a0 , a1 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1 , class A2,class Tag, class Dummy> struct implement< elementwise_<Tag>( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > ) , tag::cpu_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1 , class _A2> struct result<This(_A0 , _A1 , _A2)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 , _A2 ) > { }; template<class _A0 , class _A1 , class _A2> typename result<implement(_A0 & a0 , _A1 & a1 , _A2 & a2)>::type operator()(_A0 & a0 , _A1 & a1 , _A2 & a2) const { return map( dispatch::functor<Tag>(), a0 , a1 , a2 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1 , class A2 , class A3,class Tag, class Dummy> struct implement< elementwise_<Tag>( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > ) , tag::cpu_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1 , class _A2 , class _A3> struct result<This(_A0 , _A1 , _A2 , _A3)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 , _A2 , _A3 ) > { }; template<class _A0 , class _A1 , class _A2 , class _A3> typename result<implement(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3)>::type operator()(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3) const { return map( dispatch::functor<Tag>(), a0 , a1 , a2 , a3 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1 , class A2 , class A3 , class A4,class Tag, class Dummy> struct implement< elementwise_<Tag>( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > ) , tag::cpu_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1 , class _A2 , class _A3 , class _A4> struct result<This(_A0 , _A1 , _A2 , _A3 , _A4)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 , _A2 , _A3 , _A4 ) > { }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4> typename result<implement(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4)>::type operator()(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4) const { return map( dispatch::functor<Tag>(), a0 , a1 , a2 , a3 , a4 ); } }; } } } namespace boost { namespace simd { namespace ext { template<class A0 , class A1 , class A2 , class A3 , class A4 , class A5,class Tag, class Dummy> struct implement< elementwise_<Tag>( generic_< unspecified_<A0> > , generic_< unspecified_<A1> > , generic_< unspecified_<A2> > , generic_< unspecified_<A3> > , generic_< unspecified_<A4> > , generic_< unspecified_<A5> > ) , tag::cpu_, Dummy > { BOOST_SIMD_MAP_LOG(Tag) template<class Sig> struct result; template<class This, class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> struct result<This(_A0 , _A1 , _A2 , _A3 , _A4 , _A5)> : boost::dispatch::meta:: call<tag::map_ ( dispatch::functor<Tag> , _A0 , _A1 , _A2 , _A3 , _A4 , _A5 ) > { }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> typename result<implement(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5)>::type operator()(_A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5) const { return map( dispatch::functor<Tag>(), a0 , a1 , a2 , a3 , a4 , a5 ); } }; } } }
