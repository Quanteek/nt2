namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class X > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class X > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0> struct result<This(_Func, _A0)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type ) >::type rtype; typedef simd::native<rtype, X> type; }; template<class _A0> typename result< implement( Func const& , _A0 & a0 ) >::type operator()(Func const& f, _A0 & a0) { typename result< implement( Func const& , _A0 & a0 ) >::type that; for(size_t i = 0; i != boost::simd::meta::cardinal_of<A0>::value; ++i) insert(f(a0[i]), that, i); return that; } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class X > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X > const , simd_< unspecified_<A1>, X > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class X > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1> struct result<This(_Func, _A0 , _A1)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type ) >::type rtype; typedef simd::native<rtype, X> type; }; template<class _A0 , class _A1> typename result< implement( Func const& , _A0 & a0 , _A1 & a1 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1) { typename result< implement( Func const& , _A0 & a0 , _A1 & a1 ) >::type that; for(size_t i = 0; i != boost::simd::meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i]), that, i); return that; } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class X > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X > const , simd_< unspecified_<A1>, X > const , simd_< unspecified_<A2>, X > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class X > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2> struct result<This(_Func, _A0 , _A1 , _A2)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type ) >::type rtype; typedef simd::native<rtype, X> type; }; template<class _A0 , class _A1 , class _A2> typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2) { typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 ) >::type that; for(size_t i = 0; i != boost::simd::meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i] , a2[i]), that, i); return that; } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class X > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > , simd_< unspecified_<A3>, X > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X > const , simd_< unspecified_<A1>, X > const , simd_< unspecified_<A2>, X > const , simd_< unspecified_<A3>, X > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > , simd_< unspecified_<A3>, X > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class X > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > , simd_< unspecified_<A3>, X > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2 , class _A3> struct result<This(_Func, _A0 , _A1 , _A2 , _A3)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type , typename meta::scalar_of<_A3>::type ) >::type rtype; typedef simd::native<rtype, X> type; }; template<class _A0 , class _A1 , class _A2 , class _A3> typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3) { typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 ) >::type that; for(size_t i = 0; i != boost::simd::meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i] , a2[i] , a3[i]), that, i); return that; } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class X > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > , simd_< unspecified_<A3>, X > , simd_< unspecified_<A4>, X > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X > const , simd_< unspecified_<A1>, X > const , simd_< unspecified_<A2>, X > const , simd_< unspecified_<A3>, X > const , simd_< unspecified_<A4>, X > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > , simd_< unspecified_<A3>, X > , simd_< unspecified_<A4>, X > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class X > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > , simd_< unspecified_<A3>, X > , simd_< unspecified_<A4>, X > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2 , class _A3 , class _A4> struct result<This(_Func, _A0 , _A1 , _A2 , _A3 , _A4)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type , typename meta::scalar_of<_A3>::type , typename meta::scalar_of<_A4>::type ) >::type rtype; typedef simd::native<rtype, X> type; }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4> typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4) { typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 ) >::type that; for(size_t i = 0; i != boost::simd::meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i] , a2[i] , a3[i] , a4[i]), that, i); return that; } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class X > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > , simd_< unspecified_<A3>, X > , simd_< unspecified_<A4>, X > , simd_< unspecified_<A5>, X > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X > const , simd_< unspecified_<A1>, X > const , simd_< unspecified_<A2>, X > const , simd_< unspecified_<A3>, X > const , simd_< unspecified_<A4>, X > const , simd_< unspecified_<A5>, X > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > , simd_< unspecified_<A3>, X > , simd_< unspecified_<A4>, X > , simd_< unspecified_<A5>, X > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class X > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X > , simd_< unspecified_<A1>, X > , simd_< unspecified_<A2>, X > , simd_< unspecified_<A3>, X > , simd_< unspecified_<A4>, X > , simd_< unspecified_<A5>, X > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> struct result<This(_Func, _A0 , _A1 , _A2 , _A3 , _A4 , _A5)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type , typename meta::scalar_of<_A3>::type , typename meta::scalar_of<_A4>::type , typename meta::scalar_of<_A5>::type ) >::type rtype; typedef simd::native<rtype, X> type; }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5) { typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5 ) >::type that; for(size_t i = 0; i != boost::simd::meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i] , a2[i] , a3[i] , a4[i] , a5[i]), that, i); return that; } }; } } }
